# %%
# -*- coding: utf-8 -*-
"""tutorial_1_WaveBot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Eo1kF8d5fP7xxkl-6bjdw1PMkG7Ki8NV

# Tutorial 1 - WaveBot
The goal of this tutorial is to familiarize new users with how to set up and run optimization problems using WecOptTool.
It uses a one-body WEC, the WaveBot, in one degree of freedom in regular waves.

![WaveBot Photo](https://live.staticflickr.com/65535/51855905347_de87ccaaba_z.jpg)

At the end of this tutorial the user will perform control co-design of the WEC's geometry and a corresponding optimal controller to maximize electrical power.
We build up to this problem in three parts of successive complexity:

1. [Optimal control for maximum mechanical power](#1.-Optimal-control-for-maximum-mechanical-power)
2. [Optimal control for maximum electrical power](#2.-Optimal-control-for-maximum-electrical-power)
3. [Control co-design of the WEC's geometry for maximum electrical power](#3.-Control-co-design-of-the-WEC-geometry-for-maximum-electrical-power)

We will start by loading the necessary modules:

* Import Autograd (wrapper on NumPy, required) for automatic differentiation
* Import other packages we will use in this tutorial
* Import WecOptTool
"""

import autograd.numpy as np
#matplotlib.use('TkAgg') 
#plt.ioff()  # Turn off interactive mode 

from scipy.optimize import brute
import matplotlib.pyplot as plt
import matplotlib
#matplotlib.use('TkAgg')
#matplotlib.use('Qt5Agg')
#matplotlib.use('MacOSX')

# Override the default behavior of plt.show
original_show = plt.show
def custom_show(*args, **kwargs):
    kwargs['block'] = True  # Set block=True for all show calls
    original_show(*args, **kwargs)
plt.show = custom_show  # Replace plt.show with custom_show


import wecopttool as wot
import xarray as xr
import mhkit.wave.resource as mhkit
import capytaine as cpy

"""## 1. Optimal control for maximum mechanical power
This example illustrates how to set up, run, and analyze a basic optimization problem within WecOptTool.

The objective of this example is to **find the optimal PTO force time-series** that produces the most mechanical power subject to the WEC dynamics and a maximum force the PTO can exert.

WecOptTool requires the following to be defined to successfully run its optimization routines:
- The WEC object, including all of its properties and constraints
- The wave condition
- The objective function

<div>
<img src="https://live.staticflickr.com/65535/52435098523_37d6a2ca94_k.jpg" width="1000">
</div>

The graphic shows all the requirements for this first part of the tutorial: from the wave on the left, to the objective (mechanical power) on the right.
The WEC object, with all it's components, is illustrated in the middle. The components inside the blue box are the WEC properties that are actually passed on to the optimizer.
In short, the WEC's hydrodynamic properties are modelled by
1. Defining the WEC's geometry
2. Meshing the geometry
3. Obtaining the WEC's BEM cofficients based on the mesh
4. Determening the WEC's intrinsic impedance model based on the BEM coefficients

For this first part of the tutorial, the heave-only, WEC-PTO kinematics are trivial (Unity) and the PTO is assumed to be lossless.

### WEC object
In this section we will create the `WEC` object, which contains all the information about the WEC and its dynamics. This constitutes the vast majority of the setup required to run WecOptTool.

Our `WEC` object requires information about the mesh, degrees of freedom, mass and hydrostatic properties, linear hydrodynamic coefficients (from a BEM solution), any additional dynamic forces (e.g. PTO force, mooring, non-linear hydrodynamics), and constraints (e.g. maximum PTO extension).
In this case, the only additional force will be the PTO force and the only constraint will be a maximum PTO force of $2,000 N$.

#### Mesh
First, we will create a surface mesh for the hull and store it using the `FloatingBody` object from Capytaine. The WaveBot mesh is pre-defined in the `wecopttool.geom` module, so we will call it directly from there. We will only model the heave degree of freedom in this case. Note that the Capytaine `from_meshio` method can also import from other file types (STL, VTK, MSH, etc.)
"""

wb = wot.geom.WaveBot()  # use standard dimensions
mesh_size_factor = 0.48 # 1.0 for default, smaller to refine mesh
mesh = wb.mesh(mesh_size_factor)
fb = cpy.FloatingBody.from_meshio(mesh, name="WaveBot")
fb.add_translation_dof(name="Heave")
ndof = fb.nb_dofs

"""At this point we can visualize the mesh for inspection.
Capytaine has built-in methods for visualizing meshes (`fb.show`, and `fb.show_matplotlib`).
When running outside a Notebook, these are interactive.  
The included WaveBot example also has a method for plotting the cross-section of the device.
"""

fb.show_matplotlib()
_ = wb.plot_cross_section(show=True)  # specific to WaveBot
plt.show(block=True)

"""#### Frequency and mesh check
We will analyze 50 frequencies with a spacing of 0.05 Hz. These frequencies will be used for the Fourier representation of both the wave and the desired PTO force in the pseudo-spectral problem. See the Theory section of the Documentation for more details on the pseudo-spectral problem formulation.

The `fb.minimal_computable_wavelength` parameter checks the mesh to determine the minimum wavelength that can be reliably computed using Capytaine. This warning is ignored here because the BEM results have been validated, but can be used as a guide for mesh refinement to ensure accurate BEM results.
"""

nfreq = 30
f1 = 1.0/nfreq #0.05
freq = wot.frequency(f1, nfreq, False) # False -> no zero frequency

min_computable_wavelength = fb.minimal_computable_wavelength
g = 9.81
min_period = 1/(f1*nfreq)
min_wavelength = (g*(min_period)**2)/(2*np.pi)

if min_wavelength < min_computable_wavelength:
    print(f'Warning: Minimum wavelength in frequency spectrum ({min_wavelength}) is smaller'
         f' than the minimum computable wavelength ({min_computable_wavelength}).')

"""#### BEM
With our Capytaine floating body created, we can now run the Boundary Element Method solver in Capytaine to get the hydrostatic and hydrodynamic coefficients of our WEC object. This is wrapped into the `wecopttool.run_bem` function.

If you would like to save our BEM data to a NetCDF file for future use, see the `wecopttool.write_netcdf` function.
"""

bem_data = wot.run_bem(fb, freq)
# Print the dataset overview
print(bem_data)
# Access coordinates and dimensions
print(bem_data.dims) #Dimensions define the axes along which data varies. They are similar to the dimensions of a numpy array.
print(bem_data.coords) #Coordinates are labels for the points along the dimensions. They provide meaningful context to the numerical values in the dimensions and can be multi-dimensional. 
# Access data variables
print(bem_data.data_vars) #Data variables contain the actual data values in the Dataset
# Access specific data variable
added_mass = bem_data['added_mass']
print(added_mass)
# Plot a data variable (if suitable for visualization)
added_mass.plot()
# Select data based on coordinate values
selected_data = bem_data.sel(omega=1.0, method='nearest')
print(selected_data)
# Select data based on index
index_selected_data = bem_data.isel(omega=0)
print(index_selected_data)
# Access dataset attributes
print(bem_data.attrs)

"""#### PTO
WecOptTool includes the `PTO` class to encompass all properties of the power take-off system of the WEC. Data wrapped into our `PTO` class will be used to help define our `WEC` object and optimization problem later.

To create an instance of the `PTO` class, we need:
- The kinematics matrix, which converts from the WEC degrees of freedom to the PTO degrees of freedom. The PTO extracts power directly from the WEC's heave in this case, so the kinematics matrix is simply the $1 \times 1$ identity matrix.
- The definition of the PTO controller. The `wecopttool.pto` submodule includes P, PI, and PID controller functions that can be provided to the `PTO` class and return the PTO force. However, we will be using an unstructured controller in this case, so we will set `None` for the controller.
- Any PTO impedance. We're only interested in mechanical power for this first problem, so we will leave this empty for now
- The non-linear power conversion loss (assumed 0% if `None`)
- The PTO system name, if desired
"""

from wecopttool.pto import controller_pid

name = ["PTO_Heave",]
kinematics = np.eye(ndof)
controller = None #controller_pid # None
loss = None
pto_impedance = None
pto = wot.pto.PTO(ndof, kinematics, controller, pto_impedance, loss, name)

"""Now let's define the PTO forcing on the WEC and the PTO constraints. For our optimization problem, the constraints must be in the correct format for `scipy.optimize.minimize()`. We will enforce the constraint at 4 times more points than the dynamics (see Theory for why this is helpful for the pseudo-spectral problem)."""

# PTO dynamics forcing function
f_add = {'PTO': pto.force_on_wec}

# Constraint
f_max = 20000#2000.0
nsubsteps = 4

def const_f_pto(wec, x_wec, x_opt, waves): # Format for scipy.optimize.minimize
    f = pto.force_on_wec(wec, x_wec, x_opt, waves, nsubsteps)
    return f_max - np.abs(f.flatten())

ineq_cons = {'type': 'ineq',
             'fun': const_f_pto,
             }
constraints = [ineq_cons]

"""#### `WEC` creation
We are now ready to create the `WEC` object itself! Since we ran our BEM already, we can define the object using the `wecopttool.WEC.from_bem` function. If we saved our BEM data to a NetCDF file, we can also provide the path to that file instead of specifying the BEM `Dataset` directly.
"""

wec = wot.WEC.from_bem(
    bem_data,
    constraints=constraints,
    friction=None,
    f_add=f_add,
)

"""Note: We might receive a warning regarding negative linear damping values. Per default, WecOptTool ensures that the BEM data does not contain non-negative damping values. If you would like to correct the BEM solution manually to a minimum damping value you can specify `min_damping`.

### Waves
The wave environment must be specified as a 2-dimensional `xarray.DataArray` containing the complex amplitude (m).
The two coordinates are the radial frequency ``omega`` (rad/s)  and the direction ``wave_direction`` (rad).
The `wecopttool.waves` submodule contains functions for creating this `xarray.DataArray` for different types of wave environments.

In this case we will use a regular wave with a frequency of 0.3 Hz and an amplitude of 0.0625 m.
We will use the `wecopttool.waves.regular_wave` function.
"""

#regular wave
amplitude = 0.0625
wavefreq = 0.3
phase = 30
wavedir = 0
waves = wot.waves.regular_wave(f1, nfreq, wavefreq, amplitude, phase, wavedir)

# irregular wave
"""Te = 7.62
gamma = 3.3
fp = 1 / mhkit.energy_period_to_peak_period(Te, gamma)
hs = 1.5
spectrum = lambda f: wot.waves.jonswap_spectrum(f, fp, hs, gamma)
efth = wot.waves.omnidirectional_spectrum(f1, nfreq, spectrum, "JONSWAP")
waves = wot.waves.long_crested_wave(efth,nrealizations=2)"""

"""### Objective function
The objective function is the quantity (scalar) we want to optimizeâ€”in this case, the average mechanical power. The objective function is itself a function of the optimization state, the size of which we need to properly define our call to `scipy.optimize.minimize()`. The average mechanical power can be taken directly from the `PTO` object we created.

One technical quirk here: `nstate_opt` is one smaller than would be expected for a state space representing the mean (DC) component and the real and imaginary Fourier coefficients. This is because WecOptTool excludes the imaginary Fourier component of the highest frequency (the 2-point wave). Since the 2-point wave is sampled at multiples of $\pi$, the imaginary component is evaluated as $sin(n\pi); n = 0, 1, 2, ..., n_{freq}$, which is always zero. Excluding this component speeds up the optimization as the state space is reduced by one.
"""

obj_fun = pto.mechanical_average_power
nstate_opt = 2*nfreq # 2*nfreq ## 3 for pid and 2*nfreq for open loop

"""### Solve
We are now ready to solve the problem. WecOptTool uses `scipy.optimize.minimize` as its optimization driver, which is wrapped into `wecopttool.WEC.solve` for ease of use.

Note that the only required inputs for defining and solving the problem are: (1) the waves, (2) the objective function, and (3) the size of the optimization state. Optional inputs can be provided to control the optimization execution if desired, which we do here to change the default iteration maximum and tolerance. See `scipy.optimize.minimize` docs for more details.

To help the optimization we will scale the problem before solving it (see Documentation). WecOptTool allows you to scale the WEC dynamics state, your optimization state (in this case the Fourier coefficients for the PTO force), and the objective function separately. See the `wecopttool.WEC.solve()` function for more information.


Pay attention to the `Exit mode`: an exit mode of $0$ indicates a successful solution. For an easy problem (linear, single Dof, unconstrained, etc.) your iterations shouldn't need to exceed 100. If they do, try adjusting the scales by orders of magnitude, one at a time.
"""

options = {'maxiter': 200}
scale_x_wec = 1e1
scale_x_opt = 1e-3
scale_obj = 1e-2

results = wec.solve(
    waves,
    obj_fun,
    nstate_opt,
    optim_options=options,
    scale_x_wec=scale_x_wec,
    scale_x_opt=scale_x_opt,
    scale_obj=scale_obj,
    )

opt_mechanical_average_power = results[0].fun
print(f'Optimal average mechanical power: {opt_mechanical_average_power} W')

"""### Analyzing results
We will use two post-processing functions to obtain frequency- and time-domain results for the WEC and PTO responses. The pseudospectral method gives continuous in time results. To get smoother looking plots, we specify the number of subpoints betweeen co-location points. In this case we will use 5.
"""

nsubsteps = 5
pto_fdom, pto_tdom = pto.post_process(wec, results, waves, nsubsteps=nsubsteps)
wec_fdom, wec_tdom = wec.post_process(wec, results, waves, nsubsteps=nsubsteps)

hydro_data=wot.add_linear_friction(bem_data=bem_data)
#hydro_data = wot.linear_hydrodynamics(bem_data, mass, stiffness)
Zi = wot.hydrodynamic_impedance(hydro_data).sel(influenced_dof='Heave', radiating_dof='Heave')

from  utilities import calculate_power_flows
power_flow=calculate_power_flows(wec, pto, results, waves, Zi)
from utilities import plot_power_flow
plt.figure()
plot_power_flow(power_flow)

# compte max possibe power form theory  
# !!!!!  IMPORTANT:    this shows only upper boudn --> not time domain or frequency domain power curve!!!!
Fe_reg = (wec_fdom[0].sel(type = 'Froude_Krylov').force
          + wec_fdom[0].sel(type = 'diffraction').force
         ).sel(influenced_dof = 'DOF_0')
hydro_data=wot.add_linear_friction(bem_data=bem_data)
#hydro_data = wot.linear_hydrodynamics(bem_data, mass, stiffness)
Zi = wot.hydrodynamic_impedance(hydro_data).sel(influenced_dof='Heave', radiating_dof='Heave')

Power_max_theordy_fdom=Fe_reg**2/(8*np.real(Zi))
plt.figure()
Power_max_theordy_fdom.pipe(abs).plot()
time = wec.time_nsubsteps(nsubsteps)
time_xr = xr.DataArray(time)
Power_max_theordy_tdom = wot.time_results(Power_max_theordy_fdom, time_xr)
plt.figure()
Power_max_theordy_tdom.plot()  # as you see max is correct
plt.figure()


pto_fdom[0]['force']
pto_fdom[0]['vel']

power_mech_fdom=-0.5*np.real(np.conj(pto_fdom[0]['vel'])*pto_fdom[0]['force'])

#test: velocity should be in phase with F_ext
plt.figure()
(wec_tdom[0]['force'].sel(type='diffraction')+wec_tdom[0]['force'].sel(type='Froude_Krylov')).plot()
plt.plot(pto_tdom[0]['time'].values.flatten(),5000*pto_tdom[0]['vel'].values.flatten(),'--')

"""The `pto.post_process` function returns `xarray.Dataset`s, which have built-in integration with PyPlot for smart plotting that automagically sets titles and formatting. We will plot the mechanical power (`mech_power`), position (`pos`), and the PTO force (`force`)."""

plt.figure()
pto_tdom[0]['power'].loc['mech',:,:].plot()

"""We could similarly plot any time- or frequency-domain repsonse of the WEC or PTO. For instance, here is the PTO heave motion."""

plt.figure()
wec_tdom[0]['pos'].plot()

plt.figure()
pto_tdom[0]['force'].plot()
plt.show(block=True)

"""Note that there are other dynamic responses available in the post-processed WEC and PTO variables (`wec_tdom`, `pto_tdom`, `wec_fdom`, `pto_fdom`). For example, the time domain PTO variable contains the following response:"""

pto_tdom

"""## 2. Optimal control for maximum electrical power

The rest of this tutorial will focus on optimizing for electrical power (new objective function) rather than mechanical, as this is a form of power that is usable and transportable.

Since we're still dealing with the same WaveBot as in part 1, we can reuse the BEM and wave data from before. Look back at part 1 if you need a refresher on how to create these data.

<div>
<img src="https://live.staticflickr.com/65535/52435033525_b8efc28d16_k.jpg" width="1000">
</div>
The WEC-PTO kinematics remain the same as well (unity). The major difference now is that we consider the dynamics of PTO, since they impact the electrical power and we shall not assume a lossless PTO.

We will express the PTO's dynamics in form of a 2-port impedance model, to incoporate the dynamics of the drive-train and the dynamics of the generator.
The additional mechanical energy storage through the drive-train is modelled using Newton's second law and we assume a linear generator using a power-invariant park transform.

The PTO impedance matrix components are then obtained under open-circuit  conditions, i.e.  no  load  current  or  no  WEC  velocity,  respectively.
"""

## PTO impedance definition
omega = bem_data.omega.values
gear_ratio = 12.0
torque_constant = 6.7
winding_resistance = 0.5
winding_inductance = 0.0
drivetrain_inertia = 2.0
drivetrain_friction = 1.0
drivetrain_stiffness = 0.0

drivetrain_impedance = (1j*omega*drivetrain_inertia +
                        drivetrain_friction +
                        1/(1j*omega)*drivetrain_stiffness)

winding_impedance = winding_resistance + 1j*omega*winding_inductance


pto_impedance_11 = -1* gear_ratio**2 * drivetrain_impedance
off_diag = np.sqrt(3.0/2.0) * torque_constant * gear_ratio
pto_impedance_12 = -1*(off_diag+0j) * np.ones(omega.shape)
pto_impedance_21 = -1*(off_diag+0j) * np.ones(omega.shape)
pto_impedance_22 = winding_impedance
pto_impedance_2 = np.array([[pto_impedance_11, pto_impedance_12],
                            [pto_impedance_21, pto_impedance_22]])

"""Next, we will create a new `PTO` object with this impedance matrix. We will also update the definitions of our PTO constraint and additional dynamic forcing function to use the new object. We will set our PTO constraint to $600 N$ for this example, since the dynamics for optimal electrical power will be different."""

## Update PTO
name_2 = ['PTO_Heave_Ex2']
pto_2 = wot.pto.PTO(ndof, kinematics, controller, pto_impedance_2, loss, name_2)

## Update PTO constraints and forcing
f_max_2 = 2000#2000.0 #600.0
def const_f_pto_2(wec, x_wec, x_opt, waves):
    f = pto_2.force_on_wec(wec, x_wec, x_opt, waves, nsubsteps)
    return f_max_2 - np.abs(f.flatten())
ineq_cons_2 = {'type': 'ineq', 'fun': const_f_pto_2}
constraints_2 = [ineq_cons_2]
f_add_2 = {'PTO': pto_2.force_on_wec}

"""Finally, let's update our `WEC` object with the new PTO constraint, then run our optimization problem. Note we're now using `average_power` instead of `mechanical_average_power` as our objective function."""

# Update WEC

wec_2 = wot.WEC.from_bem(bem_data,
                         constraints=constraints_2,
                         friction=None,
                         f_add=f_add_2
)

# Update objective function
obj_fun_2 = pto_2.average_power #pto_2.mechanical_average_power #pto_2.average_power

# Solve
scale_x_wec = 1e1
scale_x_opt = 1e-3
scale_obj = 1e-2

results_2 = wec_2.solve(
    waves,
    obj_fun_2,
    nstate_opt,
    scale_x_wec=scale_x_wec,
    scale_x_opt=scale_x_opt,
    scale_obj=scale_obj,
)
opt_average_power = results_2[0].fun
print(f'Optimal average electrical power: {opt_average_power} W')

#test if we compute power using thie apporach
x_star=results_2[0].x
x_wec_star, x_opt_star = wec_2.decompose_state(x_star) # optimized values in freq domain
pto_2.average_power(
        wec_2,
        x_wec_star,
        x_opt_star,
        waves,
        nsubsteps
    ) 
pto_2.mechanical_average_power(
        wec_2,
        x_wec_star,
        x_opt_star,
        waves,
        nsubsteps
    ) 

# Post-process
wec_fdom_2, wec_tdom_2 = wec_2.post_process(wec_2, results_2, waves, nsubsteps)
pto_fdom_2, pto_tdom_2 = pto_2.post_process(wec_2, results_2, waves, nsubsteps)

"""We will compare our optimal results to the unconstrained case to gain some insight into the effect of the constraint on the optimal PTO force. Let's do the same process as before, but unset the `constraints` parameter in a new `WEC` object."""

from wecopttool.pto import _make_abcd
pto_2_impedance_abcd = _make_abcd(pto_2._impedance, pto_2._ndof)
hydro_data=wot.add_linear_friction(bem_data=bem_data)
#hydro_data = wot.linear_hydrodynamics(bem_data, mass, stiffness)
Zi = wot.hydrodynamic_impedance(hydro_data).sel(influenced_dof='Heave', radiating_dof='Heave')

Z_11 = pto_2._impedance[0, 0, :]
Z_12 = pto_2._impedance[0, 1, :]
Z_21 = pto_2._impedance[1, 0, :]
Z_22 = pto_2._impedance[1, 1, :]


excitation_force_fdom=(wec_fdom_2[0]['force'].sel(type='diffraction')+wec_fdom_2[0]['force'].sel(type='Froude_Krylov'))
V_th =  Z_21 / (-Z_11 + Zi) * excitation_force_fdom  # Equation (19)
Z_th = Z_22 + (Z_12*Z_21) / (-Z_11 + Zi)  # Equation (20)

from wecopttool import time_results
from xarray import DataArray
t_dat = wec_2.time_nsubsteps(nsubsteps)
time = DataArray(data=t_dat, name='time', dims='time', coords=[t_dat])
Vth_tdom=time_results(V_th, time)


plt.figure()
(wec_tdom_2[0]['force'].sel(type='diffraction')+wec_tdom_2[0]['force'].sel(type='Froude_Krylov')).plot()
plt.plot(pto_tdom_2[0]['time'].values.flatten(),5000*pto_tdom_2[0]['vel'].values.flatten(),'--')


plt.figure()
plt.plot(wec_tdom_2[0]['time'].values.flatten(),Vth_tdom.values.flatten(),'--')
plt.plot(wec_tdom_2[0]['time'].values.flatten(),-pto_tdom_2[0]['trans_flo'].values.flatten(),'--') #do not forget this shoudl have -


from  utilities import calculate_power_flows
power_flow=calculate_power_flows(wec_2, pto_2, results_2, waves, Zi)
from utilities import plot_power_flow
plot_power_flow(power_flow)


wec_2_nocon = wot.WEC.from_bem(
    bem_data,
    constraints=None,
    friction=None,
    f_add=f_add_2)

results_2_nocon = wec_2_nocon.solve(
    waves,
    obj_fun_2,
    nstate_opt,
    scale_x_wec=scale_x_wec,
    scale_x_opt=scale_x_opt,
    scale_obj=scale_obj,
)
opt_average_power = results_2_nocon[0].fun
print(f'Optimal average electrical power: {opt_average_power} W')
wec_fdom_2_nocon, wec_tdom_2_nocon = wec_2_nocon.post_process(wec_2_nocon,
    results_2_nocon, waves, nsubsteps)
pto_fdom_2_nocon, pto_tdom_2_nocon = pto_2.post_process(
    wec_2_nocon, results_2_nocon, waves, nsubsteps)

"""Note that the optimal constrained PTO force follows the optimal unconstrained solution (sinusoidal) whenever the unconstrained solution is within the constraint.
When the constraint is active the optimal PTO force is the maximum PTO force of $600 N$.
"""

plt.figure()
wec_tdom_2[0]['pos'].plot(label='constrained')
wec_tdom_2_nocon[0]['pos'].plot(label='unconstrained')
plt.legend(loc='lower right')

plt.figure()
pto_tdom_2[0]['force'].plot(label='constrained')
pto_tdom_2_nocon[0]['force'].plot(label='unconstrained')
plt.legend(loc='lower right')

plt.figure()
pto_tdom_2[0]['power'].loc['elec',:,:].plot(label='constrained')
pto_tdom_2_nocon[0]['power'].loc['elec',:,:].plot(label='unconstrained')
plt.legend(loc='lower right')
plt.show(block=True)

"""The attentive user might have noticed that the amplitude of the position, force and power signals is about half the magnitude of the signals we plotted in the first part of the tutorial. We can see that optimizing for electrical power requires optimal state trajectories with smaller amplitudes. For most WECs the electrical power is the usable form of power, thus the WEC should be designed for electrical power and we can avoid over-designing, which would results from expecting the forces associated with the optimal trajectories for mechanical power maximisation.

## 3. Control co-design of the WEC geometry for maximum electrical power
The first two examples only used the inner optimization loop in WecOptTool to optimize PTO power. Here in Part 3 we bring it all together and show how to use both the inner and outer optimization loops in WecOptTool to do control co-optimization of a hull design in conjunction with an optimal controller for electrical power.
Again, we use the WaveBot WEC in one degree of freedom in regular waves.
The goal is to **find the optimal keel radius** (`r2`) that maximizes the average produced electrical power, while maintaining a constant hull volume.
A constant volume is achieved by setting the height of the conical section (`h2`) in conjunction with the keel radius (`r2`).

This example demonstrates a complete case of the types of optimization studies WecOptTool is meant for.
The main optimization (outer optimization loop) is to find the optimal geometry (radius `r2`), and for each geometry considered the optimal PTO force (inner optimization loop) will be found.
The inner loop was showcased in Example 2 and uses a gradient-based optimization method, with the gradients obtained with automatic differentiation.
The outer loop optimization is for the user to setup.
In this example, we will do a simple *brute force* optimization using `scipy.optimize.brute`.  

![Device Diagram](https://live.staticflickr.com/65535/51751577441_515afec334_z.jpg)
<div>
<img src="https://live.staticflickr.com/65535/52434071157_187eb4334c_k.jpg" width="1000">
</div>

### Problem setup
First, we define a function for `h2` based on `r1` that maintains a constant volume.
We see that, as expected, smaller values of `r2` require larger values of `h2` in order to maintain a constant hull volume.
"""

r1 = 0.88
r2_0 = 0.35
h2_0 = 0.37
V0 = 1/3*np.pi*h2_0*(r1**2+r2_0**2+(r1*r2_0))

r2_vals = np.linspace(0.05, 0.88*0.999, 8, endpoint=True)


def h2_from_r2(r2, V=V0, r1=r1):
    h2 = V/(1/3*np.pi*(r1**2+r2**2+(r1*r2)))
    return h2


# plot
mapres = map(h2_from_r2, r2_vals)
h2_vals = list(mapres)

fig1, ax1 = plt.subplots(figsize=(8,5))
for r2, h2 in zip(r2_vals.tolist(), h2_vals):
    _ = wot.geom.WaveBot(r2=r2, h2=h2, freeboard=0.2).plot_cross_section(
        ax=ax1, label=f"r2={r2:.2f}, h2={h2:.2f}")
ax1.legend(loc='best', fontsize='small',ncol=2)
_ = ax1.set_title('WaveBot hull cross-sections')
plt.show(block=True)

"""Next we will define an objective function for our design optimization problem. We use the same workflow illustrated in Part 2 to set up a WaveBot device and solve for the optimal solution, but wrap this in a function definition which can set `r2` and (indirectly) `h2`."""

def design_obj_fun(x):

    # Unpack geometry variables
    r2 = x[0]
    h2 = h2_from_r2(r2)
    print(f"\nr2 = {r2:.2f}:")

    # Set up Capytaine floating body
    wb = wot.geom.WaveBot(r2=r2, h2=h2)
    mesh = wb.mesh(mesh_size_factor=0.5)
    fb = cpy.FloatingBody.from_meshio(mesh, name="WaveBot")
    fb.add_translation_dof(name="Heave")
    ndof = fb.nb_dofs

    # Run BEM
    f1 = 0.05
    nfreq = 50
    bem_data = wot.run_bem(fb, freq)

    # Impedance definition
    omega = bem_data.omega.values
    gear_ratio = 12.0
    torque_constant = 6.7
    winding_resistance = 0.5
    winding_inductance = 0.0
    drivetrain_inertia = 2.0
    drivetrain_friction = 1.0
    drivetrain_stiffness = 0.0

    drivetrain_impedance = (1j*omega*drivetrain_inertia +
                            drivetrain_friction +
                            1/(1j*omega)*drivetrain_stiffness)

    winding_impedance = winding_resistance + 1j*omega*winding_inductance


    pto_impedance_11 = -1* gear_ratio**2 * drivetrain_impedance
    off_diag = np.sqrt(3.0/2.0) * torque_constant * gear_ratio
    pto_impedance_12 = -1*(off_diag+0j) * np.ones(omega.shape)
    pto_impedance_21 = -1*(off_diag+0j) * np.ones(omega.shape)
    pto_impedance_22 = winding_impedance
    pto_impedance_3 = np.array([[pto_impedance_11, pto_impedance_12],
                            [pto_impedance_21, pto_impedance_22]])

    # Set PTO object
    name = ["PTO_Heave",]
    kinematics = np.eye(ndof)
    efficiency = None
    controller = None
    pto = wot.pto.PTO(ndof, kinematics, controller, pto_impedance_3, efficiency, name)


    # Set PTO constraint and additional dynamic force
    nsubsteps = 4
    f_max = 6000.0 #600.0

    def const_f_pto(wec, x_wec, x_opt, waves):
        f = pto.force_on_wec(wec, x_wec, x_opt, waves, nsubsteps)
        return f_max - np.abs(f.flatten())

    ineq_cons = {'type': 'ineq', 'fun': const_f_pto}
    constraints = [ineq_cons]

    f_add = {'PTO': pto.force_on_wec}

    # Create WEC
    wec = wot.WEC.from_bem(bem_data,
            constraints=constraints,
            friction=None,
            f_add=f_add,
            )

    # Waves
    wfreq = 0.3
    amplitude = 0.0625
    phase = -40
    waves_3 = wot.waves.regular_wave(f1, nfreq, wfreq, amplitude, phase)

    # Objective function
    obj_fun =pto.mechanical_average_power  #pto.average_power
    nstate_opt = 2*nfreq

    # Solve
    scale_x_wec = 1e1
    scale_x_opt = 1e-3
    scale_obj = 1e-2
    res = wec.solve(
        waves,
        obj_fun,
        nstate_opt,
        scale_x_wec=scale_x_wec,
        scale_x_opt=scale_x_opt,
        scale_obj=scale_obj)

    return res[0].fun

"""### Solve
Finally, we may call this objective function with an optimization algorithm.
Here, a simple *brute force* optimization approach is used for illustrative purposes, but any variety of options could be applied.
The optimization algorithm will call our objective function, which in turn will create a new WaveBot hull, run the necessary BEM calculations for the hull, and find the PTO force that provides the most electric power for that hull.
This process will be conducted for the range of `r2` values that we specify.

_(note: the cell below will likely take 5+ minutes to run on a standard personal computer)_
"""

wot.set_loglevel("error")  # Suppress warnings

# range over which to search
ranges = (slice(r2_vals[0], r2_vals[-1]+np.diff(r2_vals)[0], np.diff(r2_vals)[0]),)

# solve
opt_x0, opt_fval, x0s, fvals = brute(func=design_obj_fun, ranges=ranges, full_output=True,  finish=None)

"""### Results
From a quick plot of the results, we see that the power absorption (where negative power is power absorbed by the device) generally improves for smaller values of `r2`.
It is also clear that when the WEC is cylindrical (where `r2=0.88`), power absorption is reduced.
"""

fig, ax = plt.subplots()
colors = plt.rcParams['axes.prop_cycle'].by_key()['color'][:len(x0s)]
ax.plot(x0s, fvals, 'k', zorder=0)
ax.scatter(x0s, fvals, c=colors, zorder=1)
ax.set_xlabel('Keel radius, $r_2$ [m]')
ax.set_ylabel('Average Power [W]')
ax.set_title('Design optimization results')
fig.tight_layout()
plt.show()

"""Note that in this case the magnitude of average power between the different keel radii is rather small, this is because the PTO force constraint is active most of the time, therefore all considered geometries perform similarily. If you remove the PTO constraint and re-run the co-optimization study you will see that the impact of radius on average electrical power is significantly higher."""